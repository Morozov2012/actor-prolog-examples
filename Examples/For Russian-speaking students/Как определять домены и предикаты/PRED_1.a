
DOMAINS:

N		= INTEGER.
Text		= STRING.
RGB_Color	= 'Red'; 'Green'; 'Blue'.
T		= INTEGER; REAL.
Fun		= {a:INTEGER,v:REAL}.

PREDICATES:

-- В разделе PREDICATES определяются
-- предикаты, используемые в программе.
-- Перед и между определениями предикатов
-- можно использовать ключевые слова
-- "determ", "nondeterm" и "imperative".
-- Все предикаты, определяемые после
-- ключевого слова "determ" объявляются
-- детерминированными, после ключевого
-- слова "nondeterm" -
-- недетерминированными, а после ключевого
-- слова "imperative" - императивными.
-- После этих ключевых слов ставится
-- двоеточие. По умолчанию предикаты
-- объявляются детерминированными.

p(N);
s;
u();

nondeterm:

-- Раздел IMPERATIVES это то же самое что
-- раздел PREDICATES и ключевое слово
-- imperative. В разделе IMPERATIVES
-- не допускается использование ключевых
-- слов "determ", "nondeterm", "imperative".

IMPERATIVES:

p(INTEGER)	- (o);

PREDICATES:

imperative:

p(INTEGER)	- (o);

-- После имени предиката могут быть
-- перечислены имена доменов аргументов.
-- Разрешается использовать анонимные
-- домены, обозначаемые с помощью
-- анонимных переменных ("_").
-- Кроме того, в качестве аргументов можно
-- задавать имена классов.
-- После круглых скобок может следовать
-- равенство и домен результата,
-- возвращаемого функцией.
-- Затем может следовать тире и
-- (непустая) последовательность
-- образцов потоков данных.
-- Если последовательность образцов
-- потоков данных не задана, считается
-- что задан один образец вызова,
-- все аргументы которого имеют тип "i".

q(INTEGER,'Test',Color)	- (i,i,o)(o,o,o);
q			- ();
z(Color) = REAL		- (i);

-- Последнее имя домена в списке
-- может быть помечено звёздочкой,
-- обозначающей неограниченное
-- количество аргументов указанного
-- домена.

write(_*)		- (i);
format(Text,T*) = Text	- (i,i);

-- Допускается многократное определение
-- предиката с одним и тем же именем.
-- Однако при этом все предикаты
-- с одинаковым именем в рассматриваемой
-- секции должны быть сгруппированы.
-- Кроме того, внутри группы предикатов
-- с одинаковыми именами должны быть
-- сгруппированы предикаты с одинаковым
-- количеством аргументов (примечание:
-- при подсчёте числа аргументов,
-- возвращаемое значение функций не
-- учитывается, а домен, помеченный
-- звёздочкой подсчитывается просто как
-- один аргумент).

f(N) = INTEGER		- (i);
f(INTEGER)		- (o);

nondeterm:

determ:

-- Образец потоков данных представляет
-- собой последовательность деклараторов
-- направления потока данных, разделённых
-- запятыми. Последовательность
-- деклараторов заключается в круглые скобки.
-- Декларатор направления потока данных
-- может иметь значения: "i", "o", "_".

t(N,REAL,_)		- (i,i,_);

-- Транслятор проверяет, чтобы домены,
-- упоминаемые в определениях предикатов,
-- были определены где-либо в тексте программы.
-- Количество деклараторов в круглых скобках
-- должно соответствовать количеству
-- имён доменов предиката.

-- Предикаты, имитирующие правила второго
-- порядка, можно определять с помощью
-- фигурных скобок, в которых записывается
-- одно имя домена.

{Fun}			- (i);

-- Такое обозначение равнозначно обычному
-- определению предиката с именем '' и одним
-- аргументом.

''(Fun)			- (i);

-- Аналогично, допускается определение
-- функций, имитирующих правила второго
-- порядка.

{Fun} = Value		- (i);

-- Такое обозначение равнозначно обычному
-- определению функции с именем '' и одним
-- аргументом.

''(Fun) = Value		- (i);

class 'Test' (specialized 'Console'):
[
PREDICATES:

p(N,N,N)= N;
p(N,N)= N;
p(N)= N;
q(N*);

CLAUSES:

goal:-!,
	writeln("Hello world!").
--
p(1,2,3)= 4.
p(1,2)= 3.
p(1)= 2 :-!.
p(1).
p(1)= 2.
q(1,2).
q(1).
]

project: (('Test'))
