--------------------------------------------------------------------
-- (c) 2017 Alexei A. Morozov                                     --
-- Actor Prolog self-compiling compiler                           --
--------------------------------------------------------------------

package "Morozov/ActorPrologSyntax":

--------------------------------------------------------------------

DOMAINS:

ActorPrologTokens	= ActorPrologToken*.
--
ActorPrologToken =
	--
	t(ActorPrologToken,TextPosition);
	--
	'end_of_text';				-- The end of text
	'rest_of_text';				-- The rest of text
	'end_of_line';				-- End of line
	--
	'comma'; 'dot'; 'exclam';		-- , . !
	'colon'; 'semicolon';			-- : ;
	'question_mark';			-- ?
	'number_sign';				-- #
	--
	'l_round_bracket';			-- (
	'r_round_bracket';			-- )
	--
	'bar';					-- |
	'l_brace'; 'r_brace';			-- { }
	--
	'l_square_bracket';			-- [
	'r_square_bracket';			-- ]
	--
	'multiply'; 'plus'; 'minus';		-- * + -
	'divide';				-- /
	'lt'; 'eq'; 'gt';			-- < = >
	--
	'data_message';				-- <<
	'control_message';			-- <-
	'collecting_all';			-- ??
	--
	'implication';				-- :-
	'equality';				-- ==
	'assignment';				-- :=
	'ne'; 'le'; 'ge';			-- <> <= >=
	'range';				-- ..
	--
	symbol(SYMBOL,NameIsInQuotes);		-- <functor>
	vn(INTEGER);				-- <variable>
	keyword(SYMBOL);
	character(INTEGER);			-- <integer>
	integer_10(INTEGER);			-- <integer>
	integer_R(
		INTEGER,	/* Radix */
		INTEGER);	/* Value */	-- <integer>
	real_10(REAL);				-- <real>
	real_R(	INTEGER,	/* Radix */
		REAL);		/* Value */	-- <real>
	string(STRING);				-- <string>
	binary(BINARY).				-- <binary>
--
TextPosition		= INTEGER.
NameIsInQuotes		= 'no'; 'yes'.

--------------------------------------------------------------------

reference:

MetaTerms	= MetaTerm*.
--
MetaTerm =	e(MetaTerm,MetaTerm); 'empty_list';	-- List
		--
		R_INTEGER;				-- Integer
		R_REAL;					-- Real
		radix(R_INTEGER,MetaTerm);		-- Radix
		--
		symbol(R_SYMBOL);			-- Symbol
		R_STRING;				-- String
		R_BINARY;				-- Binary
		--
		structure(R_SYMBOL,MetaTerms);		-- Structure
		--
		i(UnderdeterminedSetKey,MetaTerm,MetaTerm);
		'empty_set';				-- Set
		--
		#;					-- #
		--
		var(R_INTEGER,VariableRole);		-- Variable
		slot(R_SYMBOL);				-- Slot
		--
		asterisk(MetaTerm);			-- Asterisk
		p(MetaTerm,R_INTEGER).			-- Position
--
UnderdeterminedSetKey	= R_INTEGER; R_SYMBOL.
--
VariableRole		=
			'plain';
			'rest';
			'primary_function';
			'optimized_primary_function';
			'secondary_function';
			'optimized_secondary_function';
			'meta_functor';
			'meta_predicate'.
--
R_INTEGER		= INTEGER.
R_REAL			= REAL.
R_SYMBOL		= SYMBOL.
R_STRING		= STRING.
R_BINARY		= BINARY.
--
ground:
--
SymbolList		= SYMBOL*.
--
mixed:
--
ActorPrologAtom		= atom(	ActorPrologAtomFunctor,
				ActorPrologAtomArguments,
				YesNo/*HasAsterisk*/,
				YesNo/*IsSimple*/,
				INTEGER/*Position*/).
--
ActorPrologAtomFunctor		= SYMBOL; INTEGER.
ActorPrologAtomArguments	= MetaTerms; 'metaatom'.
--
ActorPrologSubgoals	= ActorPrologSubgoal*;
			  external(STRING).
--
ActorPrologSubgoal	= subgoal(
				ActorPrologTargetParameter,
				ActorPrologSubgoalType,
				ActorPrologAtom,
				INTEGER/*Position*/).
--
ActorPrologTargetParameter	= SYMBOL; INTEGER.
--
ActorPrologSubgoalType	= plain_subgoal(
				PlainSubgoalVariety);
			  actor_subgoal(
				ActorSubgoalVariety);
			  message(
				AsyncCallVariety,
				AsyncCallUrgency,
				AsyncCallResidence).
--
PlainSubgoalVariety	= 'subroutine'; function(INTEGER).
ActorSubgoalVariety	= 'consistent'; 'temporary'.
--
AsyncCallVariety	= 'control'; 'data'.
AsyncCallUrgency	= 'deferred'; 'quick'.
AsyncCallResidence	= 'buffered'; 'superseding'.
--
ActorPrologClause	= clause(
				AtomType,
				ActorPrologAtom,
				ActorPrologSubgoals,
				INTEGER/*Position*/).
AtomType		= 'subroutine'; 'function'.
--
ActorPrologFunctionCallTable =
		ActorPrologFunctionCallDefinition*.
ActorPrologFunctionCallDefinition =
		function_call(
			INTEGER,	-- Variable
			ActorPrologSubgoal,
			YesNo,		-- Is nested call
			YesNo).		-- Is inside clause heading
--
ParserErrorType		= 'LexicalScannerError'; 'ParserError'.

--------------------------------------------------------------------
-- The 'ActorPrologScanner' class is specialized class 'Text'.    --
--------------------------------------------------------------------

interface 'ActorPrologScanner' (specialized 'Text'):
--
constant:
--
	keywords		: S_List;
	keep_text_positions	: YesNo;
--
	stop_translation_after_first_error	: YesNo;
	raise_runtime_exceptions		: YesNo;
	send_error_messages			: YesNo;
--
[
PREDICATES:
--
determ:
--
convert_to_tokens(STRING) = ActorPrologTokens		- (i);
--
imperative:
--
set_keywords(S_List)					- (i);
get_keywords() = S_List;
--
set_keep_text_positions(YesNo)				- (i);
get_keep_text_positions() = YesNo;
--
set_stop_translation_after_first_error(YesNo)		- (i);
get_stop_translation_after_first_error() = YesNo;
--
set_raise_runtime_exceptions(YesNo)			- (i);
get_raise_runtime_exceptions() = YesNo;
--
set_send_error_messages(YesNo)				- (i);
get_send_error_messages() = YesNo;
--
-- This method is to be implemented by the programmer:
--
syntax_error(	ParserErrorType,	-- Error type
		STRING,			-- Error name
		INTEGER,		-- Text position
		STRING)			-- Supplementary information
		- (i,i,i,i);
]

--------------------------------------------------------------------
-- The 'ActorPrologBacktrackableParser' class is                  --
-- specialized class 'ActorPrologScanner'.                        --
--------------------------------------------------------------------

interface 'ActorPrologBacktrackableParser'
(specialized 'ActorPrologScanner'):
--
constant:
--
	slot_names				: SymbolList;
--
[
PREDICATES:
--
determ:
--
scan_text(STRING)					- (i);
--
pop_token(ActorPrologToken) = TextPosition		- (o);
pop_ground_term(_) = TextPosition			- (o);
pop_meta_term(MetaTerm) = TextPosition			- (o);
pop_meta_expression(MetaTerm) = TextPosition		- (o);
pop_simple_atom(ActorPrologAtom) = TextPosition		- (o);
pop_function_call(ActorPrologSubgoal) = TextPosition	- (o);
pop_binary_relation(ActorPrologAtom) = TextPosition	- (o);
pop_atom(ActorPrologAtom) = TextPosition		- (o);
pop_subgoal(ActorPrologSubgoal) = TextPosition		- (o);
pop_clause(ActorPrologClause) = TextPosition		- (o);
--
check_end_of_text() = TextPosition;
--
imperative:
--
get_variable_names() = S_List;
forget_variable_names;
--
get_function_call_table() = ActorPrologFunctionCallTable;
clear_function_call_table;
--
imperative:
--
set_slot_names(SymbolList)				- (i);
get_slot_names() = SymbolList;
]
